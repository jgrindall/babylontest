


<html>
    <head>
        <script src='babylon.custom.cannon.js'></script>
        <script src='jquery.js'></script>
        <script src='hand.js'></script>
        <script src='underscore-min.js'></script>
        <script src='nipplejs.min.js'></script>
        <script src='greedymesh.js'></script>

        <style>
            #renderCanvas{
                width:90%;
                height:90%;
            }
			#zone_joystick{
                position: absolute;
                bottom:90px;
                right:90px;
            }
        </style>
    </head>
    <body>
	
        <canvas width='90%' height='90%' id="renderCanvas"></canvas>
		<p id="speed"></p>
		<div id="zone_joystick"></div>

        <script>
            var canvas, scene, engine, player, angle = 0;
			var _mode = "off";
			canvas = document.querySelector("#renderCanvas");
			var SIZE_I = 24;
			var SIZE_J = 32;
			var SIZE = 5;
			
			
            var speed = 0, ang_speed = 0, angle = 0, friction = 0.4;
			
			var makeMaterials = function(){
                brickMaterial = new BABYLON.StandardMaterial("brickMaterial", scene);
                brickMaterial.diffuseTexture = new BABYLON.Texture("brick.jpg", scene);
                brickMaterial.backFaceCulling = false
                brickMaterial.freeze();
                steelMaterial = new BABYLON.StandardMaterial("steelMaterial", scene);
                steelMaterial.diffuseTexture = new BABYLON.Texture("steel.jpg", scene);
                steelMaterial.backFaceCulling = false
                steelMaterial.freeze();
            };
			
			var setUVScale = function(mesh, uScale, vScale) {
				var i, UVs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind), len = UVs.length;
				if (uScale !== 1) {
					for (i = 0; i < len; i += 2) {
						UVs[i] *= uScale;
					}
				}
				if (vScale !== 1) {
					for (i = 1; i < len; i += 2) {
						UVs[i] *= vScale;
					}
				}
				mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, UVs);
			};
			
			var cache = {};
			
			var makeCache = function(size){
				var key = "brick_" + size[0] + "_" + size[1];
				var box = BABYLON.MeshBuilder.CreateBox(key, {height: SIZE, width:SIZE*size[0], depth:SIZE*size[1]}, scene);
				box.convertToUnIndexedMesh();
				box.material = brickMaterial;
				box.checkCollisions = true;
				setUVScale(box, size[0], size[1]);
				cache[key] = box;
				scene.meshes.pop(); // remove from the scene
			};
			var cacheI = 0;
			var getFromCache = function(size){
				var key = "brick_" + size[0] + "_" + size[1];
				var cached = cache[key];
				cacheI++;
				var box = cached.createInstance("_" + cacheI);
				box.checkCollisions = true;
				return box;
			};
			
			var addControls = function(){
				var ROT_SPEED = 0.03, SPEED = 0.6;
				var manager = nipplejs.create({
					zone: document.getElementById('zone_joystick'),
					mode: 'static',
					size:80,
					position: {
					  left: '50%',
					  top: '50%'
					},
					color: 'red'
				});
				
				manager.on("move", function(e, data){
					var d = (data.distance / 40);// from 0 to 1
					var a = data.angle.degree;
					_mode = "on";
					ang_speed = 0;
					speed = 0;
					if(d < 0.1){
						// not moved it much
						return;
					}
					if(a < 30 || a > 330){
						ang_speed = ROT_SPEED;
					}
					else if(a > 150 && a < 210){
						ang_speed = -ROT_SPEED;
					}
					else{
						speed = d * Math.sin(a*Math.PI/180) * SPEED;
						ang_speed = 0;
					}
				});

				manager.on("end", function(e, data){
					ang_speed = 0;
					speed = 0;
				});

			};

            var makeScene = function () {
                scene = new BABYLON.Scene(engine);
				scene.enablePhysics();
				var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2), scene);
				var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, -5, -2), scene);
				camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(SIZE_I*SIZE/2, 250, SIZE_J*SIZE/2), scene);
				scene.gravity = new BABYLON.Vector3(0, 0, 0);
				scene.collisionsEnabled = true;
				camera.checkCollisions = true;
				camera.applyGravity = true;
				camera.ellipsoid = new BABYLON.Vector3(5, 1, 5);
            }
			
			
			var addSky = function(){
				var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1024}, scene);
				var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
				skyboxMaterial.backFaceCulling = false;
				skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("img/skybox", scene);
				skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
				skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
				skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
				skybox.material = skyboxMaterial;
					
			};

			var addGround = function(){
				var ground = BABYLON.Mesh.CreatePlane("ground", 2000.0, scene);
				ground.material = new BABYLON.StandardMaterial("groundMat", scene);
				ground.material.diffuseTexture = new BABYLON.Texture("groundMat.jpg", scene);
				ground.material.backFaceCulling = false;
				ground.position = new BABYLON.Vector3(5, -10, -15);
				ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
				ground.checkCollisions = true;
			};

			
			var movePlayer = function(){
                var dx, dz, scaleFactor = (60/engine.getFps());
                angle += ang_speed;
				player.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), angle);
                dx = speed*Math.sin(angle) * scaleFactor;
                dz = speed*Math.cos(angle) * scaleFactor;
				player.checkCollisions = true;
				//player.isVisible = false;
                player.moveWithCollisions(new BABYLON.Vector3(dx, 0, dz));
				camera.position.x = player.position.x;
                camera.position.y = player.position.y;
                camera.position.z = player.position.z;
				camera.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), angle);
            }
			
			var ijToBabylon = function(i, j){
				var topLeft = {"x":0, "z":SIZE_I * SIZE};
				return {
					x:topLeft.x + j*SIZE,
					z:topLeft.z - i*SIZE
				};
			};
			
			var addPlayer = function(pos){
                var mat = new BABYLON.StandardMaterial("Mat", scene);
				mat.diffuseTexture = new BABYLON.Texture("img/skybox_nx.jpg", scene);
				mat.backFaceCulling = false;
				var babylonPos = ijToBabylon(pos[0], pos[1]);
				player = BABYLON.MeshBuilder.CreateBox("player", {height: SIZE, width:SIZE, depth:SIZE}, scene);
                player.material = mat;
				player.isVisible = false;
                player.checkCollisions = true;
                player.position = new BABYLON.Vector3(babylonPos.x + SIZE/2, -7, babylonPos.z + SIZE/2);
                player.ellipsoid = new BABYLON.Vector3(SIZE/3, SIZE/3, SIZE/3);
                player.setPhysicsState(BABYLON.PhysicsEngine.SphereImpostor, { mass: 0 });
            };
			
			var addWalls = function(quads){
				var y = -SIZE*1.5;
				var topLeft = {"x":0, "z":SIZE_I * SIZE};
				_.each(quads, function(quad){
					var size = (quad[2] >= quad[3]) ? [quad[2], quad[3]] : [quad[3], quad[2]];
					var wall = getFromCache(size);
					if(quad[2] < quad[3]){
						wall.rotation = new BABYLON.Vector3(0, Math.PI/2, 0);
					}
					wall.position.x = topLeft.x + (quad[1] + quad[2]/2)*SIZE;
					wall.position.z = topLeft.z - (quad[0] + quad[3]/2)*SIZE;
					wall.position.y = y;
					console.log("quad is", JSON.stringify(quad));
					console.log(wall.position);
					wall.freezeWorldMatrix();
				});
			};
			
			var birdsEye = function(){
				//camera.rotation = new BABYLON.Vector3(Math.PI/2, 0 , 0);
			};
			
			engine = new BABYLON.Engine(canvas, false, null, false);
			makeScene();
			addControls();
			makeMaterials();
			
			var img = makeRnd({rnd:0.1});
			var greedy = getBestGreedyMesh(img);
			_.each(greedy.dims, function(size){
				makeCache(size);
			});
			
			addWalls(greedy.quads);
			var empty = getEmpty(img);
			addPlayer(empty);
			addGround();
			addSky();
			birdsEye();
			
			
			scene.debugLayer.show();
            engine.runRenderLoop(function () {
				if(_mode !== "off"){
                    movePlayer();
                }
                if(_mode === "off"){
                    ang_speed *= friction;
                    speed *= friction;
                    if(Math.abs(speed) < 0.1){
                        speed = 0;
                    }
					if(Math.abs(ang_speed) < 0.1){
                        ang_speed = 0;
                    }
                }
                scene.render();
            });
            window.addEventListener("resize", function () {
               engine.resize();
            });
        </script>
		
		<script data-main="main" src="require.js"></script>
		
		
    </body>
</html>
