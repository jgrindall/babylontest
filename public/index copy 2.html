


<html>
    <head>
        <script src='babylon.custom.cannon.js'></script>
        <script src='jquery.js'></script>
        <script src='hand.js'></script>
        <script src='underscore-min.js'></script>
        <script src='pointinpoly.js'></script>
        <script src='custommesh.js'></script>
        <script src='getboundary.js'></script>
        <script src='nipplejs.min.js'></script>

        <style>
            #renderCanvas{
                width:100%;
                height:100%;

            }
            div.btn{
                width:100px;
                height:40px;
                display: inline-block;
                background: red;
                color:white;
            }
            #zone_joystick{
                position: absolute;
                bottom:60px;
                right:60px;
            }
        </style>
    </head>
    <body>
        <canvas width='100%' height='100%' id="renderCanvas"></canvas>

        <div id="zone_joystick"></div>


        <script>

            var _mode = "off"
            var manager = nipplejs.create({
                zone: document.getElementById('zone_joystick'),
                mode: 'static',
                position: {
                  left: '50%',
                  top: '50%'
                },
                color: 'red'
            });

            var ROT_SPEED = 0.025, SPEED = 0.6;

            manager.on("dir:up", function(e, data){
                _mode = "on";
                speed = SPEED;
                ang_speed = 0;
                console.log(data);
            });

            manager.on("dir:left", function(e, data){
                _mode = "on";
                speed = 0;
                ang_speed = -ROT_SPEED;
            });

            manager.on("dir:right", function(e, data){
                _mode = "on";
                speed = 0;
                ang_speed = ROT_SPEED;
            });

            manager.on("dir:down", function(e, data){
                _mode = "on";
                speed = -SPEED;
                ang_speed = 0;
            });

            manager.on("end", function(e, data){
                _mode = "off";
                ang_speed = 0;
                //speed = 0;
            });


			//https://stackoverflow.com/questions/5919298/algorithm-for-finding-the-fewest-rectangles-to-cover-a-set-of-rectangles-without/6634668#6634668

var SIZE = 5;
 var WORLD = 1500;
            var canvas, camera, engine, scene, TYPE = 2, player, sections = {};

            var l, r, speed = 0, ang_speed = 0, angle = 0, friction = 0.75;

            var y = -SIZE*1.5;

            var NUM = 50, LENGTHS = _.range(50);

            var pos = function(){
                var x = Math.random()*WORLD - WORLD/2;
                var z = Math.random()*WORLD - WORLD/2;
                if(x > 0 && x < 50){
                    x = 50;
                }
                if(x < 0 && x > -50){
                    x = -50;
                }
                if(z > 0 && z < 50){
                    z = 50;
                }
                if(z < 0 && z > -50){
                    z = -50;
                }
                return new BABYLON.Vector3(x, y, z);
            };


			canvas = document.querySelector("#renderCanvas");
			var createScene = function () {
				scene = new BABYLON.Scene(engine);
                scene.enablePhysics();
				//var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2), scene);
				var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(20, -5, -2), scene);
				camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, -8, 0), scene);
                camera.rotation = new BABYLON.Vector3(0, angle, 0);
                camera.rotation = new BABYLON.Vector3(0, 0, 0);
                var ground = BABYLON.Mesh.CreatePlane("ground", 2000.0, scene);
				ground.material = new BABYLON.StandardMaterial("groundMat", scene);
				ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
                //ground.checkCollisions = true;
				ground.material.backFaceCulling = false;
				ground.position = new BABYLON.Vector3(5, -10, -15);
				ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
				//scene.gravity = new BABYLON.Vector3(0, 0, 0);
				scene.collisionsEnabled = true;
				//camera.checkCollisions = true;
				//camera.applyGravity = false;
				camera.ellipsoid = new BABYLON.Vector3(5, 1, 5);
				ground.checkCollisions = true;

			}
            var addRnd = function(){

            };
			var addBoxes = function(){
                var mat = new BABYLON.StandardMaterial("Mat", scene);
				mat.diffuseTexture = new BABYLON.Texture("img/crate.png", scene);
				mat.backFaceCulling = false;
                var ins = 1;
                var totalLen = 0, z;
                var makeAll = function(){
                    var ALL = 0;
                    _.each(LENGTHS, function(l){
                        ALL += l*NUM;
                    });
                    alert("make 1x1 " + ALL);
                    var c = BABYLON.MeshBuilder.CreateBox("crate"+ins, {height: SIZE, width:SIZE, depth:SIZE}, scene);
                    c.material = mat;
                    c.checkCollisions = true;
                    //c.addLODLevel(150, null);
                    c.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 1 });
                    _.times(ALL, function(i){
    					var p = c.createInstance("index" + ins);
                        p.material = mat;
    					p.position = pos();
                        p.rotation = new BABYLON.Vector3(0, Math.random()*2, 0);
                        p.checkCollisions = true;
                        p.freezeWorldMatrix = true;
    					ins++;
    				});
                };
                if(TYPE === 1){
                    alert("make using cache");
                    makeMeshes();
                    var makeLen = function(len, n){
                        _.times(NUM, function(i){
        					var p = getMesh(scene, len, "brick");
                            p.position = pos();
                            p.rotation = new BABYLON.Vector3(0, Math.random()*2, 0);
                            p.checkCollisions = true;
                            p.freezeWorldMatrix = true;
        				});
                    };
                    _.each(LENGTHS, function(l){
                        makeLen(l, NUM);
                    });
                }
                else if(TYPE === 2){
                    makeAll();
                }
                console.log(totalLen);
			};
            addPlayer = function(){
                var mat = new BABYLON.StandardMaterial("Mat", scene);
				mat.diffuseTexture = new BABYLON.Texture("img/skybox_nx.jpg", scene);
				mat.backFaceCulling = false;

                player = BABYLON.MeshBuilder.CreateBox("player", {height: 1, width:1, depth:1}, scene);
                player.isVisible = false;
                //player.material = mat;
                player.checkCollisions = true;
                player.position = new BABYLON.Vector3(0, -7, 30);
                player.ellipsoid = new BABYLON.Vector3(2, 2, 2);
                player.setPhysicsState(BABYLON.PhysicsEngine.SphereImpostor, { mass: 0 });
            };


            function moveCam(){
                //angle += ang_speed;
                //camera.rotation.y = angle;
                console.log(angle, ang_speed);
                var dx, dz;
                var fps = engine.getFps();
                dx = speed*Math.sin(angle) * (60/fps);
                dz = speed*Math.cos(angle) * (60/fps);
                //camera.position.z += dz;
                //camera.position.x += dx;
                player.moveWithCollisions(new BABYLON.Vector3(dx, 0, dz));
                console.log(angle, dx, dz);
                camera.position.x = player.position.x;
                camera.position.y = player.position.y;
                camera.position.z = player.position.z;
            }

            window.addEventListener("resize", function () {
               engine.resize();
            });



            var RND = 0;
            var getMesh = function(scene, len, materialName){
                var plane, key;
            	key = materialName + "" + len;
            	plane = sections[key].createInstance("_" + RND);
            	plane.scaling.x = len;
                RND++;
                return plane;
            };

            var makeMaterials = function(){
                brickMaterial = new BABYLON.StandardMaterial("brickMaterial", scene);
                brickMaterial.diffuseTexture = new BABYLON.Texture("brick.jpg", scene);
                brickMaterial.backFaceCulling = false
                brickMaterial.freeze();
                steelMaterial = new BABYLON.StandardMaterial("steelMaterial", scene);
                steelMaterial.diffuseTexture = new BABYLON.Texture("steel.jpg", scene);
                steelMaterial.backFaceCulling = false
                steelMaterial.freeze();
            };




            var makeMeshes = function(){
            	_.each(LENGTHS, function(len){
            		var brick = BABYLON.Mesh.CreateBox("brick" + len, SIZE, scene, false, BABYLON.Mesh.DEFAULTSIDE);
            		var steel = BABYLON.Mesh.CreateBox("steel" + len, SIZE, scene, false, BABYLON.Mesh.DEFAULTSIDE);
            		brick.convertToUnIndexedMesh();
            		steel.convertToUnIndexedMesh();
            		brick.material = brickMaterial;
            		steel.material = steelMaterial;
            		setUVScale(brick, len, 1);
            		setUVScale(steel, len, 1);
            		sections["brick" + len] = brick;
            		sections["steel" + len] = steel;
            		scene.meshes.pop();
            		scene.meshes.pop();
            	});
            };

            var setUVScale = function(mesh, uScale, vScale) {
            	var i,
            		UVs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind),
            		len = UVs.length;

            	if (uScale !== 1) {
            		for (i = 0; i < len; i += 2) {
            			UVs[i] *= uScale;
            		}
            	}
            	if (vScale !== 1) {
            		for (i = 1; i < len; i += 2) {
            			UVs[i] *= vScale;
            		}
            	}
            	mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, UVs);
            };


            engine = new BABYLON.Engine(canvas, false, null, false);

            createScene();
            makeMaterials();

            addPlayer();
            addBoxes();
            scene.debugLayer.show();

            BABYLON.SceneOptimizer.OptimizeAsync(scene);

            engine.runRenderLoop(function () {
                if(_mode !== "off" && speed !== 0){
                    moveCam();
                }
                if(_mode === "off"){
                    ang_speed *= friction;
                    speed *= friction;
                    if(Math.abs(speed) < 0.1){
                        speed = 0;
                    }
                }

                scene.render();
            });


        </script>
    </body>
</html>
